<html>

<body>
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <div class="container">
        <div class="left_panel">
            <div class="filter">
                <div id='header'>
                    <h1> &#128523 Boston Bites </h1>
                    <label for="selectDistance">Distance:</label>

                    <select name="select" id="selectDistance">
                        <option value="1" selected>1 mile</option>
                        <option value="2">2 miles</option>
                        <option value="3">3 miles</option>
                        <option value="4">4 miles</option>
                        <option value="5">5 miles</option>
                        <option value="all">everywhere in Boston</option>
                    </select>
                </div>
                <div id=filter1>
                    <!-- <div class='filter1child'> -->
                    <button id = 'cb' onclick="filter1('cb')">
                        <h2>&#9749</h2>
                        <h3>Cafes & Bakeries</h3>
                    
                    </button>
                    <!-- </div> -->
                    <!-- <div class='filter1child'> -->
                    <button id = 'market' onclick="filter1('market')">
                        <h2>&#129382</h2>
                        <h3>Markets</h3>
                    </button>
                    <!-- </div> -->
                    <!-- <div class='filter1child'> -->
                    <button id = 'dd' onclick="filter1('dd')">
                        <h2>&#127863</h2>
                        <h3>Desserts & Drinks</h3>
                    </button>
                    <!-- </div> -->
                    <button id = 'restaurant' onclick="filter1('restaurant')">
                        <h2>&#127829</h2>
                        <h3>Restaurants</h3>
                    </button>
                </div>
                <div id=filter2>
                    <fieldset>
                        <legend>Pick your cuisines!</legend>
                        <input type="checkbox" id="thai" name="thai" checked>
                        <label for="thai">Thai</label>
                        <input type="checkbox" id="italian" name="italian">
                        <label for="italian">Italian</label>
                    </fieldset>
                </div>
            </div>

            <div id=mapContainer>
                <svg id="map" width=1000 height=700></svg>
            </div>


        </div>
        <div class="list">
            <h1> List </h1>
            <div id=listContainer>
                <svg id="svglist"></svg>
            </div>

        </div>
        <script>

            function filter(type){
                // helperfunc

                filter1(type);

            }
            
            
            const getData = async function () {
                const map = d3.select("svg#map");
                const width = map.attr("width");
                const height = map.attr("height");
                const margin = { top: 30, right: 20, bottom: 30, left: 20 };
                const mapWidth = width - margin.left - margin.right;
                const mapHeight = height - margin.top - margin.bottom;
                const viewport = map.append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


                let data = await d3.csv("new_boston.csv", d3.autotype);
                const boston = await d3.json("output-6.json");

                function filter1(type) {
                    // a function that filters the dataset based on the buttons in filter1.
                    // param: type, a string of the 4 types:
                    // 'cb' = cafes, bakeries
                    // 'market' = market
                    // 'dd' = drinks, desserts
                    // 'restaurant' = restaurant
                    // these strings returned by the buttons directly correlate to 'filter1' attr in data.
                    // returns: filtered data

                    allButtons = d3.selectAll('button')
                    allButtons.style('background-color','#f0f0f0')
                    
                    if (type=='cb'){
                        button = d3.select('button#cb')
                        button.style('background-color','lightgray')
                        console.log(button)
                    }

                    if (type=='market'){
                        button = d3.select('button#market')
                        button.style('background-color','lightgray')
                    }

                    if (type=='dd'){
                        button = d3.select('button#dd')
                        button.style('background-color','lightgray')
                    }

                    if (type=='restaurant'){
                        button = d3.select('button#restaurant')
                        button.style('background-color','lightgray')
                    }

                }


                console.log(boston);


                console.log(d3.map(data, d => d.latitude))
                data.forEach((d) => {
                    d.LAT = parseInt(d.latitude)
                    d.LONG = parseInt(d.longitude)
                    d.RATING = parseInt(d.rating)
                    d.REVIEW = parseInt(d.review_count)
                    d.CAT = JSON.parse(d.categories)
                    d.LOCATION = JSON.parse(d.location)
                    d.POSITION = [d.LOCATION['coordinate']['longitude'], d.LOCATION['coordinate']['latitude']];
                })
                console.log(data);

                var zips = topojson.feature(boston, boston.objects.Boston_Street_Segments);
                var zipsMesh = topojson.mesh(boston, boston.objects.Boston_Street_Segments);

                var states = topojson.feature(boston, boston.objects.City_of_Boston_Boundary);
                var stateMesh = topojson.mesh(boston, boston.objects.City_of_Boston_Boundary);

                var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], zips);
                var path = d3.geoPath().projection(projection);


                // let viewport = map.append("g");

                viewport.append("path")
                    .attr("class", "graticule")
                    .attr("d", path(d3.geoGraticule10()));


                viewport.append("path")
                    .datum(stateMesh)
                    .attr("class", "state-outline")
                    .attr("d", path);

                viewport.selectAll(".zip").data(zips.features)
                    .join("path")
                    .attr("class", "zip")
                    .attr("fill", "None")
                    .attr('stroke', 'None')
                    .attr("d", path);

                viewport.append("path")
                    .datum(zipsMesh)
                    .attr("class", "zip-outline")
                    .attr("d", path);


                // dot color scale
                dotColor = d3.scaleOrdinal(['#663300', '#2bda6e', '#cc00ff', '#ff7300']).domain(['cb', 'market', 'dd', 'restaurant'])

                viewport.selectAll("circle").data(data)
                    .join("circle")
                    .attr("class", "dots")
                    .attr("r", 5)
                    .attr("opacity", '.5')
                    .attr("cx", d => projection(d.POSITION)[0])
                    .attr("cy", d => projection(d.POSITION)[1])
                    .attr("fill", d => dotColor(d.filter1));

                var mapZoom = d3.zoom()
                    .scaleExtent([1, 20])
                    .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])  // to lock to edges
                    .on("zoom", mapZoomed);

                map.call(mapZoom);

                function mapZoomed(event) {
                    viewport.attr("transform", event.transform);

                    viewport.select(".zip-outline")
                        .style("stroke-width", 0.5 / event.transform.k);

                    viewport.selectAll("circle.dots")
                        .attr("r", 5 / event.transform.k);
                }



                // calculating circle radius
                // distance between pointA and pointB is 0.5 miles which the average person can walk in 10 minutes
                pointA = [42.361381268372234, -71.06298917928021]
                pointB = [42.35936868192185, -71.06992685719246]


                pointAxpixel = projection(pointA)[0]
                pointAypixel = projection(pointA)[1]

                pointBxpixel = projection(pointB)[0]
                pointBypixel = projection(pointB)[1]


                tenminradius = pointAxpixel - pointBxpixel
                fiveminradius = tenminradius / 2
                twentyminradius = tenminradius * 2
                thirtyminradius = tenminradius * 3

                // resource: https://www.d3indepth.com/interaction/

                viewport.on('hover', function () {
                    d3.select(this).attr('cursor', 'grab')
                })

                let drag = d3.drag()
                    .on('drag', handleDrag)

                function handleDrag(e) {
                    e.subject.x = e.x;
                    e.subject.y = e.y;
                    d3.select(this)
                        .attr("cx", e.subject.x)
                        .attr("cy", e.subject.y)
                        .attr('cursor', 'grabbing');
                    // .call(updateCircleSelection);
                    updateCircleSelection();

                    // console.log(d3.select(this));
                    // console.log(d3.select(this)._groups[0][0].isPointInFill());

                    // updateCircleSelection();


                    // function updateCircleSelection() {

                    //     let numPoints = 0;

                    //     // Base case - empty path
                    //     if (pathCoord.length < 1) {
                    //         circles.attr("fill", d => genreScale(d['Main_Genre']));
                    //     }
                    //     // Path has coords in it
                    //     else {
                    //         circles.attr("fill", d => {
                    //             // Use the scales to figure out where the point is
                    //             // d3 needs it to be in [x,y] format
                    //             let point = [yearScale(d['year']), grossScale(d['worldwide_gross'] + 1)];

                    //             // d3.polygonContains takes in a polygon as [[x,y],[x,y],[x,y]...]
                    //             // (Ideally those points go in a counter-clockwise direction, but it should work regardless)
                    //             // It will test whether a point [x,y] is inside of that polygon
                    //             if (d3.polygonContains(pathCoord, point)) {
                    //                 numPoints++;
                    //                 return "red";
                    //             }
                    //             else {
                    //                 return genreScale(d['Main_Genre']);
                    //             }
                    //         });
                    //     }
                    //     // because circles.attr "loops" through the points, our numPoints will count up the red circles
                    //     updatePanelHeader(numPoints)
                    // }

                }



                viewport.on("click", function (event) {
                    viewport.selectAll("circle.radius_circle").remove();






                    console.log(event);
                    viewport.append("circle")
                        .attr("class", "radius_circle")
                        .attr("cx", d3.pointer(event)[0])
                        .attr("cy", d3.pointer(event)[1])
                        .attr("r", tenminradius)
                        .attr("fill", "grey")
                        .attr("opacity", 0.5)
                        .attr('cursor', 'grab')
                        .call(drag);

                    updateCircleSelection();

                    // .on("mousedown", function (event) {
                    //     event.stopPropagation();
                    //     console.log('click', d3.pointer(event))
                    //     d3.select(this)
                    // .on("mousemove", function (event) {
                    //     event.stopPropagation();
                    //     console.log('move', d3.pointer(event))
                    //     d3.select(this)
                    //         .attr("cx", d3.pointer(event)[0])
                    //         .attr("cy", d3.pointer(event)[1]);
                    // })
                    // })


                })
                // These are the dots that are in the circle and should be in the list
                var selectedPoints = []
                // Find what restaurants are contained within the circle
                function updateCircleSelection() {

                    selectedPoints = [];

                    viewport.selectAll("circle.dots").each(function (d) {

                        current_circle_radius = viewport.selectAll("circle.radius_circle").attr("r")

                        // loop through all of the points
                        // find points that have a distance <= r
                        x1 = d3.pointer(event)[0]
                        y1 = d3.pointer(event)[1]

                        x2 = d3.select(this).attr("cx")
                        y2 = d3.select(this).attr("cy")

                        dist = Math.sqrt(
                            (x1 - x2) ** 2 +
                            (y1 - y2) ** 2);

                        if (dist <= current_circle_radius) {
                            // console.log(d3.select(this).attr("cx"));
                            // console.log('true')
                            selectedPoints.push(d);
                        }


                    })
                    console.log(selectedPoints);
                }
                // console.log(selectedPoints);


            };





            getData()
        </script>
</body>

</html>