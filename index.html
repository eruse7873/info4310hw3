<html>

<body>
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <div class="container">
        <div class="left_panel">
            <div class="filter">
                <div id='header'>
                    <h1> &#128523 Boston Bites </h1>
                    <label for="selectDistance">Distance:</label>

                    <select name="select" id="selectDistance">
                        <option value="1" selected>1 mile</option>
                        <option value="2">2 miles</option>
                        <option value="3">3 miles</option>
                        <option value="4">4 miles</option>
                        <option value="5">5 miles</option>
                        <option value="all">everywhere in Boston</option>
                    </select>
                </div>
                <div id=filter1>
                    <!-- buttons created using d3 -->
                </div>
                <div id=filter2>
                </div>
            </div>

            <div id=mapContainer>
                <svg id="map" width=1000 height=700></svg>
            </div>


        </div>
        <div class="list">
            <h1> List </h1>
            <div id=listContainer>

            </div>

        </div>
        <script>

            const getData = async function () {
                const map = d3.select("svg#map");
                const width = map.attr("width");
                const height = map.attr("height");
                const margin = { top: 30, right: 20, bottom: 30, left: 20 };
                const mapWidth = width - margin.left - margin.right;
                const mapHeight = height - margin.top - margin.bottom;
                const viewport = map.append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


                let data = await d3.csv("new_boston.csv", d3.autotype);
                const boston = await d3.json("output-6.json");

                // estelle's making buttons for filter1
                let f1ButtonsData = [];
                f1Label = ['market', 'cb', 'dd', 'restaurant'];
                f1H2 = ['&#129382', '&#9749', '&#127863', '&#127829'] //emojis
                f1H3 = ['Markets', 'Cafes & Bakeries', 'Desserts & Drinks', 'Restaurant'] //h3 labels

                for (let i = 0; i < f1Label.length; i++) {
                    dict = { label: f1Label[i], h2: f1H2[i], h3: f1H3[i] };
                    f1ButtonsData.push(dict);
                }
                console.log(f1ButtonsData)
                const f1div = d3.select('div#filter1')
                f1Buttons = f1div.selectAll('button').data(f1ButtonsData).join('button')
                    .on('click', filter1)

                f1Buttons.append('h2').html(d => d.h2)
                    .append('h3').text(d => d.h3)

                function filter1() {
                    // a function that filters the dataset based on the buttons in filter1.
                    // 'cb' = cafes, bakeries
                    // 'market' = market
                    // 'dd' = drinks, desserts
                    // 'restaurant' = restaurant
                    // these strings returned by the buttons directly correlate to 'filter1' attr in data.
                    // returns: filtered data

                    f1Buttons.style('background-color', '#f0f0f0') // reset colors to default
                    button = d3.select(this)
                    button.style('background-color', 'lightgray') // darken button if selected
                    f1Type = d3.select(this).datum().label; // this is the filter criteria
                    console.log(f1Type)

                    filteredData = data.filter(d => d['filter1'] == f1Type);
                    console.log(filteredData)

                    const f2div = d3.select('div#filter2')
                    if (f1Type == 'restaurant' || f1Type == 'dd') {
          
                        checkedLabels = [] // reset global variable filters 
                        
                        const filter2 = [...new Set(d3.map(filteredData, d => d.filter2))];
                        console.log(filter2)
                        // f2div.append('legend').text('more stuff')

                        f2div.selectAll('div.checkbox').remove()

                        // CREDIT: stack overflow checkboxes
                        // https://stackoverflow.com/questions/52598074/d3-checkbox-label-input-order

                        checkboxes = f2div.selectAll('.checkbox').data(filter2)
                            .enter()
                            // .append('label')
                            .append('div')
                            .attr('class', 'checkbox')
                        checkboxes.append('input')
                            // .attr("checked", true)
                            .attr('type', 'checkbox')
                            .attr('id', (d, i) => i)
                            .on('change', subFilter)
                        checkboxes.append('label')
                            .attr('for', (d, i) => i)
                            .text(d => d)

                    }

                    // remove checkboxes if others are selected

                    if (f1Type == 'cb' || f1Type == 'market')  {
                        f2div.selectAll('div.checkbox').remove() 
                    }

                    return filteredData
                }
                var checkedLabels = []; // list of stuff that is checked
                function subFilter() {

                    f2Label = d3.select(this).datum()
                    f2LabelIndex = checkedLabels.indexOf(f2Label)
                    console.log(f2Label)
                    console.log(f2LabelIndex)
                    // check if f2Label is in checkedLabels, add it
                    if (f2LabelIndex === -1) {
                        checkedLabels.push(f2Label);
                    }
                    if (f2LabelIndex > -1) {
                        checkedLabels.splice(f2LabelIndex, 1);
                    }
                    console.log(checkedLabels)
                }



                console.log(boston);


                console.log(d3.map(data, d => d.latitude))
                data.forEach((d) => {
                    d.LAT = parseInt(d.latitude)
                    d.LONG = parseInt(d.longitude)
                    d.RATING = parseInt(d.rating)
                    d.REVIEW = parseInt(d.review_count)
                    d.CAT = JSON.parse(d.categories)
                    d.LOCATION = JSON.parse(d.location)
                    d.POSITION = [d.LOCATION['coordinate']['longitude'], d.LOCATION['coordinate']['latitude']];
                })
                console.log(data);

                var zips = topojson.feature(boston, boston.objects.Boston_Street_Segments);
                var zipsMesh = topojson.mesh(boston, boston.objects.Boston_Street_Segments);

                var states = topojson.feature(boston, boston.objects.City_of_Boston_Boundary);
                var stateMesh = topojson.mesh(boston, boston.objects.City_of_Boston_Boundary);

                var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], zips);
                var path = d3.geoPath().projection(projection);


                // let viewport = map.append("g");

                viewport.append("path")
                    .attr("class", "graticule")
                    .attr("d", path(d3.geoGraticule10()));


                viewport.append("path")
                    .datum(stateMesh)
                    .attr("class", "state-outline")
                    .attr("d", path);

                viewport.selectAll(".zip").data(zips.features)
                    .join("path")
                    .attr("class", "zip")
                    .attr("fill", "None")
                    .attr('stroke', 'None')
                    .attr("d", path);

                viewport.append("path")
                    .datum(zipsMesh)
                    .attr("class", "zip-outline")
                    .attr("d", path);


                // dot color scale
                dotColor = d3.scaleOrdinal(['#663300', '#2bda6e', '#cc00ff', '#ff7300']).domain(['cb', 'market', 'dd', 'restaurant'])

                viewport.selectAll("circle").data(data)
                    .join("circle")
                    .attr("class", "dots")
                    .attr("r", 5)
                    .attr("opacity", '.5')
                    .attr("cx", d => projection(d.POSITION)[0])
                    .attr("cy", d => projection(d.POSITION)[1])
                    .attr("fill", d => dotColor(d.filter1));

                var mapZoom = d3.zoom()
                    .scaleExtent([1, 20])
                    .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])  // to lock to edges
                    .on("zoom", mapZoomed);

                map.call(mapZoom);

                function mapZoomed(event) {
                    viewport.attr("transform", event.transform);

                    viewport.select(".zip-outline")
                        .style("stroke-width", 0.5 / event.transform.k);

                    viewport.selectAll("circle.dots")
                        .attr("r", 5 / event.transform.k);
                }



                // calculating circle radius
                // distance between pointA and pointB is 0.5 miles which the average person can walk in 10 minutes
                pointA = [42.361381268372234, -71.06298917928021]
                pointB = [42.35936868192185, -71.06992685719246]


                pointAxpixel = projection(pointA)[0]
                pointAypixel = projection(pointA)[1]

                pointBxpixel = projection(pointB)[0]
                pointBypixel = projection(pointB)[1]


                tenminradius = pointAxpixel - pointBxpixel
                fiveminradius = tenminradius / 2
                twentyminradius = tenminradius * 2
                thirtyminradius = tenminradius * 3

                // resource: https://www.d3indepth.com/interaction/

                viewport.on('hover', function () {
                    d3.select(this).attr('cursor', 'grab')
                })

                let drag = d3.drag()
                    .on('drag', handleDrag)

                function handleDrag(e) {
                    e.subject.x = e.x;
                    e.subject.y = e.y;
                    d3.select(this)
                        .attr("cx", e.subject.x)
                        .attr("cy", e.subject.y)
                        .attr('cursor', 'grabbing');
                    // .call(updateCircleSelection);
                    updateCircleSelection();

                    // console.log(d3.select(this));
                    // console.log(d3.select(this)._groups[0][0].isPointInFill());

                    // updateCircleSelection();


                    // function updateCircleSelection() {

                    //     let numPoints = 0;

                    //     // Base case - empty path
                    //     if (pathCoord.length < 1) {
                    //         circles.attr("fill", d => genreScale(d['Main_Genre']));
                    //     }
                    //     // Path has coords in it
                    //     else {
                    //         circles.attr("fill", d => {
                    //             // Use the scales to figure out where the point is
                    //             // d3 needs it to be in [x,y] format
                    //             let point = [yearScale(d['year']), grossScale(d['worldwide_gross'] + 1)];

                    //             // d3.polygonContains takes in a polygon as [[x,y],[x,y],[x,y]...]
                    //             // (Ideally those points go in a counter-clockwise direction, but it should work regardless)
                    //             // It will test whether a point [x,y] is inside of that polygon
                    //             if (d3.polygonContains(pathCoord, point)) {
                    //                 numPoints++;
                    //                 return "red";
                    //             }
                    //             else {
                    //                 return genreScale(d['Main_Genre']);
                    //             }
                    //         });
                    //     }
                    //     // because circles.attr "loops" through the points, our numPoints will count up the red circles
                    //     updatePanelHeader(numPoints)
                    // }

                }



                viewport.on("click", function (event) {
                    viewport.selectAll("circle.radius_circle").remove();






                    console.log(event);
                    viewport.append("circle")
                        .attr("class", "radius_circle")
                        .attr("cx", d3.pointer(event)[0])
                        .attr("cy", d3.pointer(event)[1])
                        .attr("r", tenminradius)
                        .attr("fill", "grey")
                        .attr("opacity", 0.5)
                        .attr('cursor', 'grab')
                        .call(drag);

                    updateCircleSelection();

                    // .on("mousedown", function (event) {
                    //     event.stopPropagation();
                    //     console.log('click', d3.pointer(event))
                    //     d3.select(this)
                    // .on("mousemove", function (event) {
                    //     event.stopPropagation();
                    //     console.log('move', d3.pointer(event))
                    //     d3.select(this)
                    //         .attr("cx", d3.pointer(event)[0])
                    //         .attr("cy", d3.pointer(event)[1]);
                    // })
                    // })


                })
                // These are the dots that are in the circle and should be in the list
                var selectedPoints = []
                // Find what restaurants are contained within the circle
                function updateCircleSelection() {

                    selectedPoints = [];

                    viewport.selectAll("circle.dots").each(function (d) {

                        current_circle_radius = viewport.selectAll("circle.radius_circle").attr("r")

                        // loop through all of the points
                        // find points that have a distance <= r
                        x1 = d3.pointer(event)[0]
                        y1 = d3.pointer(event)[1]

                        x2 = d3.select(this).attr("cx")
                        y2 = d3.select(this).attr("cy")

                        dist = Math.sqrt(
                            (x1 - x2) ** 2 +
                            (y1 - y2) ** 2);

                        if (dist <= current_circle_radius) {
                            // console.log(d3.select(this).attr("cx"));
                            // console.log('true')
                            selectedPoints.push(d);
                        }


                    })
                    console.log(selectedPoints);
                    console.log(selectedPoints.length);

                    // call function to generate list of restaurants
                    generateRestaurantList(selectedPoints);
                }

                let table = d3.select(".list").append("table");

                function generateRestaurantList(points) {
                    let rowCopy = Object.assign({}, points); // shallow copy
                    let title = rowCopy.title;
                    delete rowCopy.title;

                    let kvPairs = Object.entries(rowCopy);

                    console.log('kvp')
                    console.log(kvPairs);


                    kvPairs.forEach((d) => {
                        console.log('here');
                        console.log(d);
                        console.log(d[1]['name']);

                        
                        
                        row = table.append("tr")
                        row.append("strong").text(d[1]['name']);

                        ratingrow = row.append("tr");
                        ratingrow.append("td").text("rating:");
                        ratingrow.append("td").text(d[1]['rating']);

                        addressrow = row.append("tr");
                        addressrow.append("td").text("address:");
                        addressrow.append("td").text(d[1]['LOCATION']['address']);

                    });









                }



            };





            getData()
        </script>
</body>

</html>